\section{Event sourcing}
% http://martinfowler.com/eaaDev/EventSourcing.html
% https://github.com/eventstore/eventstore/wiki/Event-Sourcing-Basics
Une des demandes pour le nouvel espace recruteur est de pouvoir suivre avec précision les actions de l'utilisateur.
Ainsi chaque modification qu'il apportera à une de ses offres ou à son profil par exemple doit être enregistrée.
%----------------------------------------------------------------------------------------
\textit{"L'idée fondamentale derrière l'Event Sourcing est d'assurer que chaque modification de l'état d'une application est capturée dans un objet événement et que ces événements sont eux-mêmes stockés dans l'ordre dans lequel ils ont été appliqués à l'application."} (Martin Fowler)
%----------------------------------------------------------------------------------------
\subsection{Fonctionnement désiré}
\label{sub:Fonctionnement desire}
Il est nécessaire de pouvoir suivre l'évolution de l'annonce que créé un utilisateur.
Concrètement, à chaque fois que l'utilisateur modifie son annonce, on veut générer un événement qui informe notre système de cette modification.
Toutes ces données pourront ainsi être utilisées pour faire des statistiques ainsi que des contrôles.
Une des utilités de ce suivi est par exemple de pouvoir contrôler les éditions abusives d'annonces déjà en ligne.
Il est ainsi possible de suivre de très près la façon dont l'utilisateur procède, ou les champs qui posent problème.

%----------------------------------------------------------------------------------------
\subsection{Fonctionnement technique}
%----------------------------------------------------------------------------------------
\subsubsection{Enregistrement de l'événement}
\label{subs:Enregistrement de l'evenement}
Concrètement, derrière chaque champ formulaire que l'utilisateur remplit, un watcher d'Angular est présent.
Ainsi lorsque ce watcher indique que le champ a été modifié, on récupère la valeur qu'il contient et envoyons cette demande de modification vers le backend.
Cette "demande de modification" est traitée comme une commande et génère alors un ou plusieurs événements qui résument la modification effectuée et sont stockés dans une base de donnée, conformément au modèle de Write du pattern CQRS décrit ci-dessus.
Chacune des modifications faite par l'utilisateur est ainsi enregistrée, et il est possible de connaître l'état du système à tout instant t donné en interrogeant la base de données.
%----------------------------------------------------------------------------------------
\subsubsection{Utilisation de l'événement}
\label{subs:Utilisation de l'evenement}
Si l'enregistrement en base se passe bien, l'événement est ensuite publié sur un EventBus, un objet Akka qui permet entre autre d'envoyer un message à des groupes d'acteurs, pour être écouté par des objets de type Projection.
Ces projections écoutent seulement une partie des événements selon leurs responsabilité et modifient en conséquence un objet DTO qu'elles indexent.
Ce traitement est fait de manière asynchrone, via le système d'acteurs Akka.
Il permet donc d'optimiser le modèle CQRS vu précédemment: la commande est exécutée rapidement puisque l'événement est sauvegardé de suite et le reste du traitement est effectué de manière asynchrone.
Cela permet d'informer quasi instantannément l'utilisateur que son action a été prise en compte.
D'autre part, en acceptant de rendre asynchrone et donc pas forcément instantannée la mise à jour de la partie Read du modèle, on améliore grandement la performance ressentie par l'utilisateur.
Le système est donc tenu à jour en lecture et ainsi, à l'appel d'une query, les projections peuvent être interrogées pour récupérer la donnée de manière très rapide.
