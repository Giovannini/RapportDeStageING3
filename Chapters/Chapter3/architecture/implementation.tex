% Pour le site Cadremploi, cette requête est une requête ElasticSearch et est donc extrêmement rapide.
% La partie de Read de l'application se résume ainsi à la simple exécution d'une requête ES et au remplissage de DTO.
%-------------------------------------------------------------------------
\subsection{Implémentation}
\label{sub:Implémentation}
L'équipe Cadremploi a été en mesure de mettre en place cette architecture particulièrement intéressante dans le projet Espace Recruteur en se basant sur plusieurs concepts tirés du Domain Driven Design (DDD) et en utilisant diverses technologies récentes.
Notamment, l'utilisation des acteurs Akka a permi une gestion confortable et performante des événements que je traiterai dans les parties suivantes et l'utilisation d'ElasticSearch a offert une rapidité en lecture importante.

%-------------------------------------------------------------------------
\subsubsection{La séparation effective de la lecture et de l'écriture}
\label{subs:La séparation effective de la lecture et de l'écriture}
L'espace recruteur utilise deux moyens différents pour accéder à la donnée en lecture et en écriture.
En effet, les données reçues des commandes sont stockées dans une base PostreSQL sous forme d'événements tandis que les données utilisées en lecture sont accessibles via un index ElasticSearch.
Cette utilisation de technologies dédiées est ainsi bien plus performant pour chaque type d'action.
\paragraph{L'écriture}
\label{par:L'écriture}
Les données sont stockées sous forme d'événements dans une base de données PostgreSQL et toute la partie écriture de l'application se fait sur cette base.
Elle n'est consultée en lecture qu'au démarrage de l'application et toute autre utilisation, sauf exception, n'est faite qu'en écriture.
Plus qu'en écriture seule, les données ne peuvent être qu'insérées (append only), c'est à dire que les données déjà présente ne sont jamais modifiées.
Une ligne de cette base contient ainsi la donnée relative à un événement, la date d'application de cet événement sur le système ainsi que l'identifiant de l'aggrégat sur lequel s'applique l'événement.
L'idée fondamentale de l'Event Sourcing est qu'en enregistrant chaque événements occurant sur un système, on peut retrouver l'état de ce système à tout instant; cette base est finalement une liste de tous les événements ayant eu lieu depuis le démarrage de l'application.
\subparagraph{Cohérence de la base}
Comme expliqué précédemment, plusieurs contrôles sont effectués avant la validation d'une commande pour assurer la validité de l'information insérée et donc la cohérence de la base.
En effet, cette "liste d'événement" est la base de l'application de l'Espace Recruteur et l'information qui y est présente est utilisée pour construire/reconstruire l'application.
Une corruption de la donnée qui y est présente n'est donc pas envisageable.
Ce type de stockage est néanmoins extrêmement rapide, ce qui nous intéresse du point de vue des commandes puisqu'on essaye de donner à l'utilisateur un retour quasi immédiat sur son action.
\subparagraph{Migration des événements}
Evidemment, l'application Espace Recruteur est vouée à changer au cours du temps et des modifications y seront apportées.
Ainsi, il est quasiment certain que les événements existant aujourd'hui seront modifiés, enrichis voire même supprimés pour certain, et qu'ils ne peuvent donc rester totalement statique en base.
J'ai ainsi travaillé sur un outil de migration des événements de cette base dans le cas d'une modification de la sorte.
La migration des événements contenus dans la base est nécessaire de manière à ne pas figer le comportement de l'application ni devoir être gêné continuellement par des comportements obsolètes dans le futur.
Il s'agit donc d'une nuance à la non-modification des données de cette base.
\subparagraph{}
L'utilisation d'une base PostgreSQL en append only permet la réalisation de l'Event Sourcing

\paragraph{La lecture}
\label{par:La lecture}
Les données disponibles en lecture le sont depuis un index ElasticSearch qui est mis en place au démarrage de l'application.
ElasticSearch est un moteur de recherche open source qui permet de disposer en quelques minutes seulement d'un moteur de recherche clusterisé, automatiquement sauvegardé et répliqué et interrogeable via une API REST.
Cet index est mis à jour de manière asynchrone à la réception d'une intention de l'utilisateur.
En effet, l'utilisateur a besoin d'agir avec le système de manière la plus synchrone possible, dans le sens où un feedback immédiat est nécessaire pour assurer que chaque action opérée a bien été prise en compte.
Il est alors envisageable d'accepter de rendre la partie lecture du système cohérentes quelques millisecondes plus tard seulement pour maximiser cette réactivité du système.
On accepte ainsi un léger décalage entre le temps d'exécution de la commande et la mise à jour de la partie lecture.
Concrètement, cela signifie, par exemple, que lors de la modification de son adresse email, l'ancienne peut encore être affiché pendant quelques instants quand l'utilisateur sait que son action a bien été prise en compte.
\paragraph{}
En somme, les parties d'écriture et de lecture sont physiquement séparées dans l'application Espace Recruteur de Cadremploi

%-------------------------------------------------------------------------
\subsubsection{Les commandes}
\label{subs:Les commandes}
Dans l'espace recruteur de Cadremploi, une commande représente une action venant de l'utilisateur visant à modifier les données le concernant.
Cela peut s'agir de son profil utilisateur, des entreprises qu'il gère ou bien des annonces qu'il a écrites.
\paragraph{L'interface}
\label{par:L'interface}
%%TODO image d'un champ rempli, de la requête Json générée et de l'envoi à l'application
L'interface de l'espace recruteur est pensée de sorte à ce que le recruteur qui l'utilise envoit des commandes à l'application de manière transparente.
En effet, à chaque champ du formulaire rempli, une requête Ajax contenant les informations relatives à la modification est envoyée à l'application.
Concrètement, on utilise un élément d'AngularJS permettant d'enregistrer un callback à exécuter lorsqu'une expression ciblée est modifiée.
Cet élément est appelé watcher.
Cette technologie permet des appels asynchrones à la fonction de callback.
Généralement, cette fonction effectue des vérifications côté client de la saisie du client avant de générer un appel REST de type POST à destination de l'espace recruteur.
Cet appel sera interprété et traduit en une commande que l'on tentera d'exécuter.
\paragraph{Backend}
\label{par:Backend}
L'utilisation du pattern Command est rendu possible grâce à plusieurs objets.
\subparagraph{Les objets Command}
\label{subp:Les objets Command}
Comme expliqué précédemment, une commande est un appel de méthode encapsulé dans un objet.
L'équipe Cadremploi a choisi de décorréler l'exécution de l'action et la description de l'intention de l'utilisateur.
Concrètement, cela signifie qu'une classe se charge de la définition de la commande, tandis qu'une seconde traitera l'exécution de l'action.
%%TODO schéma UML de la séparation Command/CommandHandler
Ce découpage en Command et CommandHandler est légèrement plus verbeux, mais permet néanmoins de réduire la taille des classes que nous écrivons et offre la possibilité d'un traitement asynchrone.
En effet, on peut imaginer placer les commandes sur une queue qui sera traitée par les CommandHandlers dès que la ressource nécessaire à leur exécution se trouve disponible.
Une logique similaire qui n'est pas encore exploitée par Cadremploi serait d'envisager un mode déconnecté puisqu'il est possible d'exécuter des commandes en local qui seront envoyés sur le serveur et donc traitées effectivement dès que la connexion est récupérée.

\subparagraph{Le command executor}
\label{subp:Le command executor}
Un exécuteur de commande (ou "CommandExecutor") est une entitée créée pour être utilisée à l'exécution de chaque commande.
Cette classe expose une méthode permettant d'exécuter une commande donnée.
Cet exécuteur se charge de:
\begin{itemize}
  \item retrouver l'aggrégat visé par la commande s'il existe
  \item vérifier que l'auteur de l'action est autorisé à l'effectuer
  \item récupérer le CommandHandler associé à la commande
  \item
\end{itemize}


% parler des technos avant peut être (Akka, Angular, ...)
\paragraph{} % Mettre cette partie dans la section "implementation"?
Un des points à noter ici est que contrairement à la couche de modification des données, cette couche ne nécessite pas une mise à jour immédiate.
En effet, lorsqu'un utilisateur modifie le système, il a besoin d'un retour immédiat l'informant que son action a bien été prise en compte.
Néanmoins il peut accepter qu'un délai ait lieu avant la prise en compte à l'affichage de sont action.
On peut ainsi, pour offrir plus de confort à l'utilisateur, il est possible d'user d'asynchronisme et rendre la partie en lecture de notre application cohérente "plus tard" (généralement quelques millisecondes plus tard
