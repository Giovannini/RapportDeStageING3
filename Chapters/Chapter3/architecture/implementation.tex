% Pour le site Cadremploi, cette requête est une requête ElasticSearch et est donc extrêmement rapide.
% La partie de Read de l'application se résume ainsi à la simple exécution d'une requête ES et au remplissage de DTO.
%-------------------------------------------------------------------------
\subsection{Implémentation}
\label{sub:Implémentation}
L'équipe Cadremploi a été en mesure de mettre en place cette architecture particulièrement intéressante dans le projet espace recruteur en se basant sur plusieurs concepts tirés du Domain Driven Design (DDD) et en utilisant diverses technologies récentes.
En effet, l'utilisation des acteurs Akka a permi une gestion confortable et performante des événements que je traiterai dans les parties suivantes et l'utilisation d'ElasticSearch a offert une rapidité en lecture importante.
L'utilisation de l'architecture CQRS est rendue possible grâce à plusieurs concepts tirés du Domain Driven Design (DDD) ainsi qu'à l'utilisation de technologies récentes.

%-------------------------------------------------------------------------
\subsubsection{La séparation effective de la lecture et de l'écriture}
\label{subs:La séparation effective de la lecture et de l'écriture}
L'espace recruteur utilise deux moyens différents pour accéder à la donnée en lecture et en écriture.
Cela permet l'utilisation de technologies dédiées et donc plus performantes pour chaque type d'action.
\paragraph{L'écriture}
\label{par:L'écriture}
Les données sont stockées dans une base de données PostgreSQL et toute la partie écriture de l'application se fait sur cette base.
Cette base n'est consultée en lecture qu'au démarrage de l'application et toute autre utilisation, sauf exception, n'est faite qu'en lecture.
De plus, l'utilisation d'event sourcing demande d'exécuter cette écriture uniquement en ajout (append only) puisque tout événement est conservé puisqu'il fait partie de l'histoire de l'application.
C'est grâce à cette certification que la partie lecture de l'application peut se faire de manière totalement séparée.
\paragraph{La lecture}
\label{par:La lecture}
Les données disponibles en lecture le sont depuis un index ElsaticSearch qui est mis en place au démarrage de l'application.
%%TODO choix elasticsearch
Cet index est mis à jour de manière asynchrone à la réception d'une intention de l'utilisateur.
On accepte ainsi un léger décalage entre le temps d'exécution de la commande et la mise à jour de la partie lecture.
En effet, l'utilisateur a besoin d'agir avec le système de manière la plus synchrone possible, dans le sens où un feedback immédiat est nécessaire pour assurer que chaque action opérée a bien été prise en compte.
Il est alors envisageable d'accepter de rendre la partie lecture du système cohérentes quelques millisecondes plus tard seulmement pour maximiser cette réactivité du système.
Concrètement, cela signifie, par exemple, que lors de la modification de son adresse email, l'ancienne peut encore être affiché pendant quelques instants quand l'utilisateur sait que son action a bien été prise en compte.

%-------------------------------------------------------------------------
\subsubsection{Les commandes}
\label{subs:Les commandes}
Dans l'espace recruteur de Cadremploi, une commande représente une action venant de l'utilisateur visant à modifier les données le concernant.
Cela peut s'agir de son profil utilisateur, des entreprises qu'il gère ou bien des annonces qu'il a écrites.
\paragraph{L'interface}
\label{par:L'interface}
%%TODO image d'un champ rempli, de la requête Json générée et de l'envoi à l'application
L'interface de l'espace recruteur est pensée de sorte à ce que le recruteur qui l'utilise envoit des commandes à l'application de manière transparente.
En effet, à chaque champ du formulaire rempli, une requête Ajax contenant les informations relatives à la modification est envoyée à l'application.
Concrètement, on utilise un élément d'AngularJS permettant d'enregistrer un callback à exécuter lorsqu'une expression ciblée est modifiée.
Cet élément est appelé watcher.
Cette technologie permet des appels asynchrones à la fonction de callback.
Généralement, cette fonction effectue des vérifications côté client de la saisie du client avant de générer un appel REST de type POST à destination de l'espace recruteur.
Cet appel sera interprété et traduit en une commande que l'on tentera d'exécuter.
\paragraph{Backend}
\label{par:Backend}
L'utilisation du pattern Command est rendu possible grâce à plusieurs objets.
\subparagraph{Les objets Command}
\label{subp:Les objets Command}
Comme expliqué précédemment, une commande est un appel de méthode encapsulé dans un objet.
L'équipe Cadremploi a choisi de décorréler l'exécution de l'action et la description de l'intention de l'utilisateur.
Concrètement, cela signifie qu'une classe se charge de la définition de la commande, tandis qu'une seconde traitera l'exécution de l'action.
%%TODO schéma UML de la séparation Command/CommandHandler
Ce découpage en Command et CommandHandler est légèrement plus verbeux, mais permet néanmoins de réduire la taille des classes que nous écrivons et offre la possibilité d'un traitement asynchrone.
En effet, on peut imaginer placer les commandes sur une queue qui sera traitée par les CommandHandlers dès que la ressource nécessaire à leur exécution se trouve disponible.
Une logique similaire qui n'est pas encore exploitée par Cadremploi serait d'envisager un mode déconnecté puisqu'il est possible d'exécuter des commandes en local qui seront envoyés sur le serveur et donc traitées effectivement dès que la connexion est récupérée.

\subparagraph{Le command executor}
\label{subp:Le command executor}
Un exécuteur de commande (ou "CommandExecutor") est une entitée créée pour être utilisée à l'exécution de chaque commande.
Cette classe expose une méthode permettant d'exécuter une commande donnée.
Cet exécuteur se charge de:
\begin{itemize}
  \item retrouver l'aggrégat visé par la commande s'il existe
  \item vérifier que l'auteur de l'action est autorisé à l'effectuer
  \item récupérer le CommandHandler associé à la commande
  \item
\end{itemize}


% parler des technos avant peut être (Akka, Angular, ...)
\paragraph{} % Mettre cette partie dans la section "implementation"?
Un des points à noter ici est que contrairement à la couche de modification des données, cette couche ne nécessite pas une mise à jour immédiate.
En effet, lorsqu'un utilisateur modifie le système, il a besoin d'un retour immédiat l'informant que son action a bien été prise en compte.
Néanmoins il peut accepter qu'un délai ait lieu avant la prise en compte à l'affichage de sont action.
On peut ainsi, pour offrir plus de confort à l'utilisateur, il est possible d'user d'asynchronisme et rendre la partie en lecture de notre application cohérente "plus tard" (généralement quelques millisecondes plus tard
